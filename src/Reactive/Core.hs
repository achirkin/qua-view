{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE KindSignatures, DataKinds #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE ExistentialQuantification #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Reactive.Core
-- Copyright   :  (c) Artem Chirkin
-- License     :  BSD3
--
-- Maintainer  :  Artem Chirkin <chirkin@arch.ethz.ch>
-- Stability   :  experimental
--
--
--
-----------------------------------------------------------------------------

module Reactive.Core
    ( R (..)
    , Reaction (..)
    , EventSense (..)
    , createEventSense
    ) where

import Language.Haskell.TH
import GHC.TypeLits
import Data.List (foldl', groupBy)


-- | Empty data type declaring the type of reaction to use
data R (name :: Symbol) = R

-- | Process all available reactions - instances should by generated by TH
class EventSense program event where
    -- | process all reactions on given event
    processAllReactions :: event -> program -> program

-- | Implement this to have a reaction on an event. Reaction transforms a program
class Reaction program event (name :: Symbol) where
    -- | Basic template for event processing functions.
    --   If event is not known, default implementation just return unmodified program
    react :: R name -> event -> program -> program
    react _ _ = id

-- | Create EventSense instance declarations for all Reaction instances available in the scope
createEventSense :: Q [Dec]  -- [SR PointerClickEvent Int]
createEventSense = do
    ClassI _ instances <- reify ''Reaction
    let expr = map ( -- create SRs from instances
              \xs@(InstanceD _ (AppT (AppT (AppT _ pt) et) _) _ : _) ->
                ( ListE
                  $ map (\(InstanceD _ (AppT _ reactionName) _)
                  -> ConE 'SR `AppE` SigE (ConE 'R) (AppT (ConT ''R) reactionName)) xs
                , InstanceD [] (AppT (AppT (ConT ''EventSense) pt) et) []
                )
            )
            . groupBy ( -- by event and program types
                \(InstanceD _ (AppT (AppT (AppT _ pt1) et1) _) _)
                 (InstanceD _ (AppT (AppT (AppT _ pt2) et2) _) _)
                -> pt1 == pt2 && et1 == et2)
            $ instances
        decs = flip map expr $ \(srs, InstanceD _ t _)
            -> InstanceD [] t [FunD 'processAllReactions [
                    Clause [] (NormalB $ AppE (VarE 'prList) srs) []
                ]]
    return decs

----------------------------------------------------------------------------------------------------


-- | hide name of the reaction - existential data type
data SR program event = forall name . Reaction program event name => SR (R name)


-- helper function to process event by reaction list
prList :: [ SR program event ]
       -> event
       -> program -> program
prList rs ev program = foldl' (\p (SR r) -> react r ev p) program rs
